### 类组件

基于ES6的class语法，通过继承React.Component得来的React组件。

```jsx
import { Component } from 'react'

class ProfilePage extends from Component {
  showMessage = _ => {
		alert('followed' + this.props.user)
  }
  
  handleClick = _ => {
    setTimeout(showMessage, 3000)
  }
  
  componentDidMounted() {
    ...
  }
  
  render() {
    return <button onClick={this.handleClick}>Follow</button>
  }
}
```



### 函数组件/无状态组件

以函数形态存在的组件。在早期react版本中没有hooks，函数组件内部无法定义和维护状态，因此也叫无状态组件。

```jsx
function ProfilePage(props) {
  showMessage() {
    alert('followed' + props.user)
  }
  handleClick() {
    setTimeout(showMessage, 3000)
  }
  
  return <button onClick={handleClick}>Follow</button>
}
```



### 函数组件与类组件对比（没有hooks之前）：

1. 类组件需要继承自React.Component，函数组件不需要；

2. 类组件可以访问生命周期方法，函数组件不能

3. 类组件可以获得实力化后的this，函数组件不可以；

4. 类组件可以自定义并维护state，函数组件不行；

   ....

### 重新理解类组件：包裹在面向对象里的“重装战舰”

在以上类组件例子里可以看出，类组件中预置了很多“现成”的东西，比如state和生命周期，只需继承React.Component就可以。但这也暴露了一个问题--它提供了多少东西，你就得学多少东西。假设没有彻底理解生命周期，就有可能把组件逻辑变得一塌糊涂。

更不可忽视的是，由于我们编写的逻辑在封装后是和组件耦合在一起，这就使得类组件 内部的逻辑难以实现拆分和复用。 如果想打破这种僵局，则需要更加复杂的设计模式（比如高阶组件HOC，Render Props等等）

### 函数式组件：呼应React设计思想的“轻巧快艇”

相比于类组件，函数式组件肉眼可见的轻量、灵活、易于组织。除此之外还有一个重要的区别：

> 函数组件会捕获 render 内部的状态，这是两类组件最大的不同

可以阅读[这篇文章](https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/)，这个特性更契合React的设计思想。作为开发者，我们编写的代码是声明式的，react的工作就是及时的把声明式代码转换为命令式的DOM操作，把数据层面的描述映射到用户可见的UI变化中去。这就意味着，React的数据应该总是紧紧的和渲染绑定在一起，而类组件做不到这一点。至于为什么做不到，可以阅读[这篇文章](https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/)。

### Hooks的本质：一套能够使函数组件更强大、更灵活的钩子。

React Hooks的出现，就是为了帮助函数组件补齐相比于类组件缺失的能力。

### 从核心API看Hooks的基本形态

#### useState(): 为函数组件引入状态

在过去可能为了使用state不得不编写一个类组件。

```jsx
import {Component} from 'react'

class TextButton extends Component {
  this.state = {
    text: '初始文本'
  }
	
	changeText = _ => {
    this.setState({
      text: '修改后的文本'
    })
  }
  
  render() {
    return (
    	<>
      <p>{this.state.text}</p>
      <button onClick={this.changeText}>点击修改文本</button>
      </>
    )
  }
}
```

有了useState后，我们就可以在函数组件里引用state了

```jsx
import { useState } from 'react'

function TextButton() {
  const [text, setText] = useState('初始文本')
  
  changeText() {
    setText('修改后的文本')
  }
  
  return (
  	<>
    <p>{text}</p>
    <button onClick={changeText}>点击修改文本</button>
		</>
  )
}
```



#### useState快速上手

从用法上看，useState返回的是一个数组，第一个元素对应的是我们想要的state的变量，第二个对应的是能够修改这个变量的api.

```js
const [state, setState] = useState(initState) // 解构出来的变量可以随意命名，语法上不报错
```

但这个initState并不像类组件中的state一样，组件的整个状态都在state对象内部收敛，而是单独一个状态，并且这个状态可以是任意类型，需要多个状态时可以多次调用useState

```js
const [role, setRole] = useState(['kabuda', 'shayulajiao']) //定义为数组
const [age, setAge] =useState(10) //定义为number
```

#### useEffect(): 允许函数组件执行副作用的操作

useEffect能够为函数组件引入副作用，来代替类组件中的生命周期里做的事。比如订阅事件、调用API等

#### useEffect() 快速上手

useEffect可以接收两个参数，分别是回调函数和依赖数组

```js
useEffect(callback, [])
```

useEffect如何使用取决想达到什么效果：

* 每一次渲染后都执行的副作用：传入回调函数，不依赖数组

  ```js
  useEffect(callback)
  ```

* 仅在挂载阶段执行的副作用：传入回调函数，且这个回调函数的返回值不是一个函数，同时传入空数组

  ```js
  useEffect(_ => {}, [])
  ```

* 仅在挂载和卸载阶段执行的副作用：传入回调函数，并且回调函数返回一个函数，同时传入空数组

  ```js
  useEffect(_ => {
  	return _ => {}
  }, [])
  ```

  useEffect回调函数中返回的函数被称为“清除函数”，当react识别到清除函数时，会在调用新的effect逻辑之前执行清除函数内部的逻辑。这个规律不会受第二个参数或者其它因素的影响，只要你在useEffect回调中返回了一个函数，它就会被作为清除函数来处理。

* 每一次渲染都触发，且卸载阶段也会被触发的副作用：传入回调函数，且这个回调的返回值是一个函数，同时不传入第二个参数

  ```js
  useEffect( _ => {
    return _ => {}
  })
  ```

* 根据一定的依赖条件来触发的副作用：传入回调函数，同时传入一个非空数组

  ```js
  useEffect(_ => {}, [state1, state2, ...])
  ```

  数组中的变量一般都来自于组件本身的数据（例如state或者props）。若数组不为空，那么React就会在新的一次渲染后去比对两次的渲染，查看数组内是否有变量发生变化（只要有一个数组元素发生变化，就会被认为更新发生了），并在有更新的前提下去触发useEffect的副作用